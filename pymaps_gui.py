"""
-This program uses tkinter for the user interface. PIL is used to load images into tkinter.
-Folium is used to generate the maps. MatIcon is a plug in that I created to have more control
over the look of map markers.
-The tile_styler is a function in the constants that adds more variety to the map selection
that comes with folium.
-Geopy is used to generate the geo locations from addresses.
-Pandas is used to read, validate, and save data set files.
-Subprocess, webbrowser, and os are used to handle paths, folders and files.
-All the constants for this program are in the constants.py


Features of the program:
-Accepts any size data sets to plot into a map. The data sets can be in excel, csv, and json formats.
-It can generate geo locations using an address, or use already available geo locations in the data set.
-Using pandas the program validates the data set for geo locations and addresses.
-It accepts multiple data set to be added into the map.
-Each data set will be its own layer with its own properties.
-The user can select a column in the data set using a drop down menu, and use that column information
to create a pop up with information for the markers on the map.
-The customization of the markers can be set by the user, or generated by the program if the user
does not want to customize the markers.
-Marker color and Icon color can be picked using a color picker.
-Saved layers can be edited, deleted or added at any point to add great flexibility to the user.
-A treeview displays the properties of each layer to be added to the map.
-A map style window easily allows the user to select a desired map style available in the custom tile_styler.
-When the map is created, if the data set file provided did not contain a geo location, and the program generated
the geo locations, the program creates cache files with geo locations to speed up future use of that data set.
-The program is able to find available cached files created from previous use of the program.
-It can also continue from previous saved progress from cache files.
-It uses the cache files by default, but allows the user to set an option to not use the cache, or can open the
cache folder to view the cache files.
-The program accounts for the use of large data set files. It saves its progress whenever the stop button is pressed,
when a geo location time out error occurs, or every 50 geo locations generated, in case of an unaccounted for error.
-The program also displays a working progress bar, and displays text status related to what the program is doing.
It also allows the user to select a folder to save the map html file, and generates the needed js, and css files
in the same location.

"""

from tkinter import *
from tkinter.ttk import *
from tkinter import filedialog
from tkinter import colorchooser
from tkinter.filedialog import asksaveasfilename
from tkinter import messagebox
from ttkthemes import themed_tk as tk
from PIL import ImageTk, Image
from folium.plugins.mat_icon import MatIcon
import folium
from geopy.geocoders import ArcGIS
import pandas as pd
import subprocess
import webbrowser
import random
import os
from pymaps.constants import *

lat_list = []
lon_list = []
geo_locator = ArcGIS(timeout=10)
total_locations = 0
locations_processed = 0
map_layers = []
empty_layer = ''
unique_id = 0


# CLASS OBJECT TO HANDLE MAP LAYERS

class MapLayer:
    """
    This class contains all the attributes and methods needed for creating each layer of the map.
    The actual map layer is contained in the layer attribute.
    The file method opens the data set file and checks it.
    The create layer method creates the folium layer object, and tells the file method
    to use cache file, or input file.
    The default values method picks a random value from the default values.
    The add markers method adds marker objects to the folium layer.
    The get lat and lon method gets the geo locations using geopy.
    The add label method adds the labels to each marker.
    """

    def __init__(self, layer_id='', layer_name=''):

        self.layer_id = layer_id
        self.file_path = ''
        self.cache_path = ''
        self.use_cache = 1
        self.file_name = ''
        self.data_frame = ''
        self.data_frame_edited = False
        self.lat_lon_available = ''
        self.layer_name = layer_name
        self.label = ''
        self.marker_color = ''
        self.icon = ''
        self.icon_color = ''
        self.layer = ''
        self.columns = []
        self.locations_processed = 0

    def read_data(self, path):
        # Use the correct pandas.read depending on file extension to create the pandas data frame.
        if path[-3:] == 'csv':
            self.data_frame = pd.read_csv(path)
        if path[-3:] == 'lsx':
            self.data_frame = pd.read_excel(path)
        if path[-3:] == 'son':
            self.data_frame = pd.read_json(path)
        # Make the columns in the data set lower case.
        self.data_frame.columns = map(str.lower, self.data_frame.columns)
        # Check if lat and lon are available in the columns.
        for lat_lon_column in column_check[-2:]:
            if lat_lon_column not in self.data_frame.columns:
                # If lat and lon not available check for address.
                for add_city_st_column in column_check[:2]:
                    if add_city_st_column not in self.data_frame.columns:
                        # Set data frame to empty if the data set does not
                        # contain location information and return error.
                        self.data_frame = ''
                        return 'error'
            # Record if the geo locations were available.
                self.lat_lon_available = 'False'
            else:
                self.lat_lon_available = 'True'
        # Split the file path to grab the file name.
        self.file_name = path.split('/')[-1]
        # Name or set index in data frame. This is done for the cache files saved.
        try:
            self.data_frame.set_index('index', inplace=True,)
        except:
            self.data_frame.index.name = 'index'
        # Reset columns to empty. This is done for when a layer is edited, or a cache file is used, and
        # a new data frame is created.
        self.columns = []
        # Add the columns in the data frame to the column list of the layer.
        for column in self.data_frame.columns:
            self.columns.append(column)

    def check_cache(self):
        # This cache method is used for when a user creates a map with a new data set file without
        # a cache, and the user presses create map again. The program will use the new generated cache.

        # Look for a previously generated cache file.
        cache_file = 'cached\\Pymaps_' + self.file_path.split('/')[-1].split('.')[0] + '.csv'
        # If the cache file exists, set the cache path.
        if os.path.exists(cache_file):
            self.cache_path = cache_file
        # If the use cache option is on, and the cache path is not empty then create a new data frame
        # from the cache file.
        if self.use_cache == 1 and len(self.cache_path) > 0:
            self.read_data(cache_file)

    def create_layer(self):
        # If use cache is selected, then use the cache file, else use the original file to create the
        # data frame.
        if self.use_cache == 1 and len(self.cache_path) > 0:
            self.read_data(self.cache_path)
        else:
            self.read_data(self.file_path)
        # Create the folium layer.
        self.layer = folium.FeatureGroup(name=self.layer_name)
        self.default_values()

    def default_values(self):
        # If any of the self values for marker color, icon and icon color are empty
        # choose a random value from defaults.
        if len(self.marker_color) < 1:
            self.marker_color = random.choice(default_colors)
        if len(self.icon) < 1:
            self.icon = random.choice(default_icons)
        if len(self.icon_color) < 1:
            self.icon_color = 'white'

    def stop(self):
        # If the stop button was pressed.
        if stop_progress.get() == 'enabled':
            # Show process stopped.
            total_locations_var.set(process_stopped)
            # Create a cache of this layer.
            create_cache(self)
            # Reset edited status to False. This is done to reset the layer for the next Create map press.
            self.data_frame_edited = False
            return True

    def save(self):
        # After each marker is created call the add progress function and pass self.
        add_progress(self)
        # Track locations processed for self in order to save progress after 50 locations processed.
        self.locations_processed += 1
        if self.locations_processed == 50:
            create_cache(self)
            # Reset count
            self.locations_processed = 0

    def add_markers(self):

        # Check the cache options before creating the markers.
        self.check_cache()
        # If the geo locations columns were not available.
        if self.lat_lon_available == 'False':
            # Add lon lat columns to data frame and fill rows with pending. This is done to save progress
            # of generated geo locations into a cache file.
            self.data_frame['latitude'] = 'pending'
            self.data_frame['longitude'] = 'pending'
        # For every row in the data frame.
        for row in range(self.data_frame.shape[0]):
            # If the row value in the longitude column is a NaN or pending. This is done when using incomplete
            # cache files from previous runs.
            if pd.isna(self.data_frame.loc[row, 'longitude']) or \
                    self.data_frame.loc[row, 'longitude'] == 'pending':
                # Pass the row index to the get lat lon method to generate geo location.
                self.get_lat_lon(row)
            # Append the geo locations to the lat and lon lists
            lat_list.append(float(self.data_frame['latitude'][row]))
            lon_list.append(float(self.data_frame['longitude'][row]))
            # Add a marker to the folium layer.
            self.layer.add_child(folium.Marker(
                # Grab the row geo locations from the data frame columns.
                location=[self.data_frame['latitude'][row], self.data_frame['longitude'][row]],
                # Pass the row index to the label method to generate the label.
                popup=(self.add_label(row)),
                # Set the marker attributes from the self values.
                icon=MatIcon(marker_color=self.marker_color,
                             icon_color=self.icon_color,
                             icon=self.icon)
            ))
            # Update progress and save
            self.save()
            # Stop and break the loop and continue to make the map with the created markers.
            if self.stop():
                break

    def get_lat_lon(self, row):
        # This method generates geo locations and adds them to the data frame.
        # Set the data frame edited attribute as True. Used for deciding when to write to cache.
        self.data_frame_edited = True
        # Generate geo location object using the values in the rows for the
        # address, city and state columns.
        try:
            geo_location = geo_locator.geocode('{},{},{}'.format(
                self.data_frame['address'][row],
                self.data_frame['city'][row],
                self.data_frame['state'][row], ))
        except:
            messagebox.showerror(title=time_out_title, message=time_out_message)
            processing('enabled')
        self.data_frame.loc[row, 'latitude'] = geo_location.latitude
        self.data_frame.loc[row, 'longitude'] = geo_location.longitude

    def add_label(self, row):
        # If the selected label column exists in the data frame
        # return the value of that row.
        if self.label in self.data_frame.columns:
            return str(self.data_frame[self.label][row])
        # Else use the address as label
        else:
            return "{},\n{},\n{},".format(
                self.data_frame['address'][row],
                self.data_frame['city'][row],
                self.data_frame['state'][row])


# MAIN PROGRAM FUNCTIONS BY PROCESS ORDER

def create_empty_layer():
    global unique_id, empty_layer
    # Check map layers for an existing empty layer.
    for map_layer in map_layers:
        # If an empty layer already exists.
        if map_layer.layer_name == empty_layer:
            # Move the empty layer to the last index of the layer list.
            map_layers.append(map_layers.pop(map_layers.index(map_layer)))
            return
    # Create an empty layer variable with a random number.
    empty_layer = random.randint(333333, 999999)
    # Create a MapLayer class object with the layer name of the empty layer variable,
    # and give it a unique id.
    map_layers.append(MapLayer(layer_name=empty_layer, layer_id=unique_id))
    # Add a value to unique id.
    unique_id += 1


def select_file():
    # Important: the last layer on the layer list is always the active layer to saved.
    # Open dialog box to select file, restrict file types.
    file_path = filedialog.askopenfilename(title="Select Data Set", filetypes=(
        ("csv files", "*.csv"), ("excel files", "*.xlsx"), ("json files", "*.json")),
                                           initialdir="/", )
    # If the window was closed without selecting a file do nothing.
    if len(file_path) < 1:
        return
    # Clear entries when a new data set when a new data set is selected.
    clear_entries()
    # Check for a cached file.
    check_cache(file_path)
    # Call the read file method of the map layer object.
    read_file = map_layers[-1].read_data(file_path)
    # Show error if the file method returned error and clear file path entry.
    if read_file == 'error':
        messagebox.showerror(title=data_set_error_title, message=data_set_error)
        file_path_var.set('')
        return
    # Set the file path of last active layer
    map_layers[-1].file_path = file_path
    # Set the file path string to the layer file name
    file_path_var.set(map_layers[-1].file_name)
    # Run create label function.
    create_label_menu()


def check_cache(file_path):
    # Check for an existing cache file.
    cache_file = 'cached\\Pymaps_' + file_path.split('/')[-1].split('.')[0] + '.csv'
    # If the file exists then enable the cache features and set cache path of the layer.
    if os.path.exists(cache_file):
        use_cached_box.configure(state='enabled')
        show_cached_button.configure(state='enabled')
        if map_layers[-1].use_cache == 1:
            cached_box_var.set(1)
        map_layers[-1].cache_path = cache_file


def create_label_menu():
    # Set the label name tkinter string variable to the default column label.
    label_name.set(label_default)
    # Insert the default column label to the map layer columns attribute.
    map_layers[-1].columns.insert(0, label_default)
    # For each column in the map layer columns attribute.
    for column in map_layers[-1].columns:
        # Add a label column to the tkinter label menu object, set the command
        # for each value in the menu as set the label name tkinter string to the value.
        label_menu['menu'].add_command(
            label=column, command=lambda label=column: label_name.set(label))


def pick_color(mode):
    # Open the color picker window.
    color = colorchooser.askcolor()[1]
    # If the window was closed without picking a color do nothing.
    if color is None:
        return
    # Set the marker color tkinter string to the color picked.
    if mode == 'marker':
        marker_color_code.set(color)
    # Set the icon color tkinter string to the color picked.
    if mode == 'icon':
        icon_color_code.set(color)


def pick_icon():
    # Open a window with the icon options and show the information.
    webbrowser.open_new(icon_style_link)
    messagebox.showinfo(title=icon_info_title, message=icon_style_info)


def check_fields(*args):
    # If there are arguments.
    if len(args) > 0:
        # If the file name of the map layer object is not empty. This warning is for
        # when the user clicks create map or edit layer, and there is an active unsaved layer.
        if len(map_layers[-1].file_name) > 0:
            # Show input message about incomplete layer (continue yes or no)
            incomplete_layer = messagebox.askyesno(title=incomplete_layer_title,
                                                   message=args[0])
            # Return the choice made.
            return incomplete_layer
        # If the file name of the layer is empty do nothing.
        return
    # Show empty field error for the file entry.
    if len(file_entry.get()) == 0:
        messagebox.showerror(title=file_error_title, message=file_error)
        return
    # Show empty field error for the layer entry.
    if len(layer_entry.get()) == 0:
        messagebox.showerror(title=layer_empty_title, message=layer_empty_error)
        return
    # If checkbox is not marked down and the marker color or icon color or icon style
    # entry fields are empty ask if they want those values to be set to default.
    if default_box_var.get() == 0 and (len(marker_color_entry.get()) < 1 or
                                       len(icon_style_entry.get()) < 1 or
                                       len(icon_color_entry.get()) < 1):
        choice = messagebox.askyesno(title=default_values_title,
                                     message=default_values_message)
        # If they click no do nothing.
        if not choice:
            return
    # Get the entries if no errors.
    get_entries()


def get_entries():
    global total_locations
    # There is always an empty layer in the map layer list. Which means that
    # if there are more than one layers then there is a saved layer in the list.
    # If the length of the map layers list is more than 1.
    if len(map_layers) > 1:
        # Check all the map layers in the map layer list except for the last one.
        for map_layer in map_layers[:-1]:
            # If the map layer name in the entry already exists show error and don't get entries.
            if map_layer.layer_name == layer_entry.get():
                messagebox.showerror(title=existing_layer_title,
                                     message=existing_layer_error)
                return
    # Add the locations of the layer data frame to the total locations
    total_locations += map_layers[-1].data_frame.shape[0]
    # Update the string vars
    update_status_strings()
    # Grab all the values from the tkinter entries and create the tree view.
    map_layers[-1].use_cache = cached_box_var.get()
    map_layers[-1].layer_name = layer_entry.get()
    map_layers[-1].label = label_name.get()
    map_layers[-1].marker_color = marker_color_code.get()
    map_layers[-1].icon = icon_style_entry.get()
    map_layers[-1].icon_color = icon_color_code.get()
    # Call the create layer method of the layer.
    map_layers[-1].create_layer()
    create_tree_view()


def create_tree_view():
    # Set the identifier to the active layer id.
    identifier = map_layers[-1].layer_id
    # If there are no tree views with this identifier create one, clear the entries and return.
    if not tree_view.exists(identifier):
        tree_view.insert('', '0', iid=identifier,
                         text=map_layers[-1].layer_name)
        tree_view.insert(identifier, '1', 'file_name' + str(identifier),
                         text='File: {}'.format(map_layers[-1].file_name))
        tree_view.insert(identifier, '2', 'label' + str(identifier),
                         text='Label: {}'.format(map_layers[-1].label))
        tree_view.insert(identifier, '3', 'locations' + str(identifier),
                         text='Locations: {}'.format(
                             map_layers[-1].data_frame.shape[0]))
        tree_view.insert(identifier, '4', 'marker_color' + str(identifier),
                         text='Marker Color: {}'.format(
                             map_layers[-1].marker_color))
        tree_view.insert(identifier, '5', 'icon_style' + str(identifier),
                         text='Icon Style: {}'.format(map_layers[-1].icon))
        tree_view.insert(identifier, '6', 'icon_color' + str(identifier),
                         text='Icon Color: {}'.format(
                             map_layers[-1].icon_color))
        clear_entries()
        return
    # If tree view exists then edit it and clear the entries.
    tree_view.item(identifier, text=map_layers[-1].layer_name)
    tree_view.item('file_name' + str(identifier),
                   text='File: {}'.format(map_layers[-1].file_name))
    tree_view.item('label' + str(identifier),
                   text='Label: {}'.format(map_layers[-1].label))
    tree_view.item('locations' + str(identifier),
                   text='Locations: {}'.format(
                       map_layers[-1].data_frame.shape[0]))
    tree_view.item('marker_color' + str(identifier),
                   text='Marker Color: {}'.format(map_layers[-1].marker_color))
    tree_view.item('icon_style' + str(identifier),
                   text='Icon Style: {}'.format(map_layers[-1].icon))
    tree_view.item('icon_color' + str(identifier),
                   text='Icon Color: {}'.format(map_layers[-1].icon_color))
    clear_entries()


def clear_entries():
    # Delete the values from all the entries, and set the tkinter strings to empty.
    file_path_var.set('')
    layer_entry.delete(0, END)
    label_menu['menu'].delete(0, END)
    marker_color_entry.delete(0, END)
    icon_style_entry.delete(0, END)
    icon_color_entry.delete(0, END)
    label_name.set('')
    # Disable the cache features.
    use_cached_box.configure(state='disable')
    show_cached_button.configure(state='disable')
    # Create a new empty layer.
    create_empty_layer()
    # Layer and map buttons are disabled if no map layer has been saved. Enable buttons after
    # saving and creating a layer.
    if len(map_layers) > 1:
        create_map_button.configure(state='enabled')
        delete_layer_button.configure(state='enabled')
        edit_layer_button.configure(state='enabled')
        map_style_button.configure(state='enabled')
        map_style_entry.configure(state='readonly')
        # Set the map style to the default.
        map_style_var.set(map_style_default)


def delete_layer():
    global total_locations
    # Grab the tree view id from the selected layer.
    selected_item = tree_view.selection()
    # Delete the tree view using the id.
    tree_view.delete(selected_item)
    # If the id from the selected item is the same as the id as the map layer in the last index
    # index position (last index position map layer is always the active one) clear the entries
    # and remove the map layer from the layer list.

    if int(selected_item[0]) == map_layers[-1].layer_id:
        map_layers.remove(map_layers[-1])
        clear_entries()
        update_status_strings()

    # If the layer being deleted is not the active one. Check all the map layers and if
    # the map layer has the same tree view id, delete it and subtract its locations from total locations.
    # Break the loop after the map layer was found.
    for map_layer in map_layers:
        if map_layer.layer_id == int(selected_item[0]):
            if map_layer.layer_id != map_layers[-1].layer_id:
                total_locations -= map_layer.data_frame.shape[0]
                update_status_strings()
            map_layers.remove(map_layer)
            break
    # Disable buttons and clear entries if there are no remaining saved map layers.
    if len(map_layers) == 1:
        create_map_button.configure(state='disabled')
        delete_layer_button.configure(state='disabled')
        edit_layer_button.configure(state='disabled')
        map_style_button.configure(state='disabled')
        map_style_entry.config(state='disabled')
        # If the active layer does not have a cache then disable the cache UI.
        if len(map_layers[-1].cache_path) < 1:
            use_cached_box.configure(state='disabled')
            show_cached_button.configure(state='disabled')
        map_style_var.set('')


def edit_layer():
    global total_locations
    # Grab the tree view id from the selected tree.
    selected_item = tree_view.selection()
    # If the selected item id is the same as the last layer, do nothing when pressing edit.
    if int(selected_item[0]) == map_layers[-1].layer_id:
        return
    # If the id of the selected item is not the same as the id of the active map layer.
    # Go to the check fields function and ask if user wants to continue without saving.
    if map_layers[-1].layer_id != int(selected_item[0]):
        edit = check_fields(edit_continue_message)
        # If they answered no then do nothing.
        if edit == False:
            return
        # Else if the last layer is not the empty one, add the locations to the total locations
        elif map_layers[-1].layer_name != empty_layer:
            total_locations += map_layers[-1].data_frame.shape[0]
            update_status_strings()
    # Check the map layers for the selected id.
    for map_layer in map_layers:
        # If the id is the same as the selected item.
        if map_layer.layer_id == int(selected_item[0]):
            # Put the map layer at the end of the list to be the active layer.
            map_layers.append(map_layers.pop(map_layers.index(map_layer)))
            # subtract the locations of the layer from the total locations.
            total_locations -= map_layer.data_frame.shape[0]
            update_status_strings()
            # Delete the values of the label option menu.
            label_menu['menu'].delete(0, END)
            # And set the entry variables and tkinter strings tot he map layer saved attributes.
            marker_color_code.set(map_layer.marker_color)
            icon_color_code.set(map_layer.icon_color)
            file_path_var.set(map_layer.file_name)
            icon_style.set(map_layer.icon)
            layer_name_str.set(map_layer.layer_name)
            label_name.set(map_layer.label)
            cached_box_var.set(map_layer.use_cache)
            # Check for a cache file during the edit. This is done for when the user created the map
            # and a cache was generated. The user should be able to choose whether to use the cache or not.
            check_cache(map_layer.file_path)
            # Add a label column to the tkinter label menu object, set the command
            # for each value in the menu as set the label name tkinter string to the value.
            for column in map_layer.columns:
                label_menu['menu'].add_command(
                    label=column, command=lambda label=column: label_name.set(label))
            return


def processing(state):
    # Disable buttons while the layers are being processed.
    # Enable the buttons when the map has finished, or the stop button was pressed, and
    # disable the stop button.
    stop_progress.set(state)
    file_button.configure(state=state)
    file_entry.configure(state=state)
    layer_entry.configure(state=state)
    layer_label.configure(style='{}.TLabel'.format(state))
    label_menu.configure(state=state)
    label_label.configure(style='{}.TLabel'.format(state))
    marker_color_entry.configure(state=state)
    marker_color_pick.configure(state=state)
    marker_color_label.configure(style='{}.TLabel'.format(state))
    icon_style_entry.configure(state=state)
    icon_style_button.configure(state=state)
    icon_color_label.configure(style='{}.TLabel'.format(state))
    icon_color_entry.configure(state=state)
    icon_color_pick.configure(state=state)
    save_layer_button.configure(state=state)
    default_box.configure(state=state)
    edit_layer_button.configure(state=state)
    delete_layer_button.configure(state=state)
    map_style_button.configure(state=state)
    map_style_entry.configure(state=state)
    create_map_button.configure(state=state)

    if state == 'enabled':
        stop_button.configure(state='disabled')


def create_map():
    # Checks entry fields for unfinished layers.
    create = check_fields(create_map_continue_m)
    # If user answers no then do nothing.
    if create == False:
        return
    # Else clear entries, disable the buttons, enable the stop button, and update the status strings.
    clear_entries()
    processing('disabled')
    stop_button.configure(state='enabled')
    update_status_strings()

    # Loop all the layers in the list.
    for map_layer in map_layers:
        # Move the empty layer to the last index in the map layers list.
        if map_layer.layer_name == empty_layer:
            map_layers.append(map_layers.pop(map_layers.index(map_layer)))
        # If the layer is not the empty one.
        if map_layer.layer_name != empty_layer:
            # Call the add markers method of the map layer.
            map_layer.add_markers()
            # Create a cache when the layer is done.
            create_cache(map_layer)

    # Grab the tiles and attr from the map styler and create the map where the map layers will go.
    # Tile styler is on the constants file.
    tiles, attr = tile_styler(map_style_var.get())
    map_base = folium.Map(tiles=tiles, attr=attr, location=map_location(),
                          zoom_start=zoom_start())
    # Add the layers to the map if the layer is not the empty layer.
    for map_layer in map_layers:
        if map_layer.layer_name != empty_layer:
            map_base.add_child(map_layer.layer)
    # Set the geo loc stat tkinter string to completed.
    geo_loc_stat.set('Completed')
    # Add layer control to the map
    map_base.add_child(folium.LayerControl())
    save_map(map_base)


def save_map(map_base):
    # Show the save window and the file type to save as.
    file_type = [('Save HTML Map', '*.html')]
    save_file = asksaveasfilename(filetypes=file_type, defaultextension=file_type)
    # Re-enable buttons when map is done.
    processing('enabled')
    # Reset the lists once the map is created.
    global lat_list, lon_list
    lat_list = []
    lon_list = []
    # Create the necessary JS and CSS files for the map to open properly.
    folder_path = "/".join(save_file.split('/')[:-1])
    with open(folder_path + '/mat_icon.js', 'w+') as file:
        file.write(js_code)
    with open(folder_path + '/mat_icon.css', 'w+') as file:
        file.write(css_code)
    # Save the file and open the file.
    map_base.save('{}'.format(save_file))
    os.startfile('{}'.format(save_file))


def create_cache(map_layer):
    # Creates a new data set file with the generated lon and lat values if the original data set
    # did not have those columns. This is done for future use of the data set without having
    # to generate the geo locations again.
    if map_layer.data_frame_edited == True:
        try:
            # Create the cache folder if it doesnt exist.
            if not os.path.exists('cached\\'):
                os.mkdir('cached\\')
            # If the file being used is the pymaps cache file save the file with the same file name.
            # This is done in case the cache file had changes made to it, or was used as the input.
            if 'Pymaps' in map_layer.file_name:
                map_layer.data_frame.to_csv('{}'.format(map_layer.file_name))
            else:
                # Create a cache file with Pymaps name.
                map_layer.data_frame.to_csv('cached\\Pymaps_{}'.format(map_layer.file_name))
        except:
            # Show error if the file is open and cant be saved
            messagebox.showerror(title='Pymaps data set is open',
                                 message='The pymaps data set is currently open.\n'
                                         'Please close it in order to continue.')
            # Loop this function until file is closed
            create_cache(map_layer)


# HELPER AND ATTRIBUTE FUNCTIONS ---
def update_status_strings():
    # This function updates the tkinter variables displayed when a layer is changed, deleted,
    # or map created.
    global locations_processed, total_locations
    progress_bar['value'] = 0
    locations_processed = 0
    geo_loc_stat.set('')
    total_locations_var.set('Locations to Process: {}'.format(total_locations))
    locations_processed_var.set('')


def add_progress(map_layer):
    # This function shows the progress bar and progress messages as the locations are
    # generated and set on the map.
    global locations_processed
    # If the geo locations were not available in the data set, show a message about generating them.
    if map_layer.lat_lon_available == 'False':

        geo_loc_stat.set(generating_geo)
    else:
        # Show message about using the available geo locations.
        geo_loc_stat.set(using_geo)
    # Add 1 to the processed locations.
    locations_processed += 1
    # Set the tkinter string variable to locations processed and format in the locations processed variable.
    locations_processed_var.set('Locations processed: {}'.format(locations_processed))
    # Step is the 100 percent progress bar divided by the total locations.
    step = 100 / total_locations
    # Add a step to the progress bar per location processed.
    progress_bar['value'] += step
    # Update while idle.
    base.update()


def map_location():
    # Generate the map starting location by getting the mean of lat and lon.
    lat = sum(lat_list) / len(lat_list)
    lon = sum(lon_list) / len(lon_list)
    return [lat, lon]


def zoom_start():
    # Generate the zoom start depending on the distance between the min and max lon values.
    distance = max(lon_list) - min(lon_list)
    if distance < 0.05:
        zoom = 20
    if 0.05 < distance < 0.10:
        zoom = 16
    if 0.10 < distance < 0.20:
        zoom = 15
    if distance > 1:
        zoom = 5
    return zoom


def about(mode):
    # Show about page and message.
    if mode == 'about':
        webbrowser.open_new(about_link)
        messagebox.showinfo(title=about_title, message=about_message)
    # Show info message.
    if mode == 'info':
        messagebox.showinfo(title=info_title, message=info_message)



# TKINTER WINDOWS AND USER INTERFACE --

def map_style():
    # This is the map style window where the user selects the map style they want to use.
    def change_image(selected):
        # Load the image from the map style dictionary using the selected key value.
        load_image = ImageTk.PhotoImage(Image.open(map_style_dict[selected]))
        show_map.configure(image=load_image)
        show_map.img = load_image

    def set_style():
        # When the user presses ok in the window, set the map style tkinter string to
        # the temporary map variable and destroy the window.
        map_style_var.set(temp_map_var.get())
        tile_win.destroy()

    # Create map window.
    tile_win = Toplevel(base)
    # Calculate center of the screen.
    x = str(int(tile_win.winfo_screenwidth() / 2 - (map_win_width / 2)))
    y = str(int(tile_win.winfo_screenheight() / 2 - (map_win_height / 2)))
    # Set window attributes.
    tile_win.title(map_window_title)
    tile_win.resizable(False, False)
    tile_win.iconbitmap(window_icon)
    tile_win.geometry("{}x{}+{}+{}".format(map_win_width, map_win_height, x, y))
    # Take priority while its open.
    tile_win.attributes('-topmost', True)
    tile_win.grab_set()
    # Create window assets and widgets.
    tile_label = Label(tile_win, text='Select a Style')
    temp_map_var = StringVar()
    select_style = OptionMenu(tile_win, temp_map_var, *[s for s in map_style_dict],
                              command=change_image)
    temp_map_var.set(map_style_var.get())
    image = ImageTk.PhotoImage(Image.open(map_style_dict[map_style_var.get()]))
    show_map = Label(tile_win, image=image)
    ok_button = Button(tile_win, text='OK', command=set_style)
    select_style.config(width=16)
    # Place the widgets
    tile_label.pack(side=TOP, pady=10)
    show_map.pack(side=TOP)
    select_style.pack(side=TOP, pady=10)
    ok_button.pack(side=TOP)
    tile_win.mainloop()


def base_config():
    # Main window configuration
    x = str(int(base.winfo_screenwidth() / 2 - (main_win_width / 2)))
    y = str(int(base.winfo_screenheight() / 2 - (main_win_height / 2)))
    base.set_theme(ttk_theme)
    base.title(main_window_title)
    base.resizable(False, False)
    base.iconbitmap(window_icon)
    base.geometry("{}x{}+{}+{}".format(main_win_width, main_win_height, x, y))
    # Main window top menu, file menu and help menu
    menu = Menu(base)
    base.config(menu=menu)
    file_menu = Menu(menu, tearoff=0)
    help_menu = Menu(menu, tearoff=0)
    menu.add_cascade(label='File', menu=file_menu)
    menu.add_cascade(label='Help', menu=help_menu)
    file_menu.add_command(label='Open Data', command=select_file)
    file_menu.add_command(label='Exit', command=base.quit)
    help_menu.add_command(label='Info', command=lambda: about('info'))
    help_menu.add_command(label='About', command=lambda: about('about'))


# Create base window and content frame
base = tk.ThemedTk()
base_config()

# Set styles
style = Style()
style.configure('disabled.TLabel', foreground='#c5ccd0')
style.configure('enabled.TLabel', foreground='#3e3e3e')

# Create empty map layer
create_empty_layer()

# Create Left Frame
left_frame = Frame(base)
left_frame.place(x=0, y=0, width=210)

# Create Left Frame Assets
canvas = Canvas(left_frame, width=208, height=480)
banner = ImageTk.PhotoImage(Image.open(left_banner))

# Create Left Frame Widgets
canvas.create_image(15, 15, anchor=NW, image=banner)

# Place Left Frame Widgets
canvas.pack()

# Create Main Frame
main_frame = Frame(base, width=200, height=750)
main_frame.place(x=220, y=10, width=350)

# Create Main Frame string and int variables.
cached_box_var = IntVar()
cached_box_var.set(1)
label_name = StringVar()
marker_color_code = StringVar()
icon_color_code = StringVar()
file_path_var = StringVar()
layer_name_str = StringVar()
icon_style = StringVar()
default_box_var = IntVar()
color_picker_icon = PhotoImage(file=color_picker_image)
geo_loc_stat = StringVar()
total_locations_var = StringVar()
locations_processed_var = StringVar()
stop_progress = StringVar()
# Create Main Frame widgets
# Cache
use_cached_box = Checkbutton(main_frame, text='Use Cached Data', state='disabled',
                             offvalue=0, onvalue=1, variable=cached_box_var)
show_cached_button = Button(main_frame, command=lambda: subprocess.Popen(r"explorer .\cached"),
                            text='Show Cache', width=12, state='disabled')

# File
file_button = Button(main_frame, text="Select File", width=12,
                     command=select_file)
file_entry = Entry(main_frame, textvariable=file_path_var, width=18
                   , state='readonly')
# Layer
layer_label = Label(main_frame, text="Layer Name:", style='enabled.TLabel')
layer_entry = Entry(main_frame, textvariable=layer_name_str, width=18)
# Label menu
label_label = Label(main_frame, text="Label Column:", style='enabled.TLabel')
label_menu = OptionMenu(main_frame, label_name, '')
label_menu.config(width=14)
# Marker color
marker_color_label = Label(main_frame, text="Marker Color:", style='enabled.TLabel')
marker_color_entry = Entry(main_frame, textvariable=marker_color_code, width=13,
                           style='MC.TEntry')
marker_color_pick = Button(main_frame, width=1,
                           image=color_picker_icon, compound=RIGHT,
                           command=lambda: pick_color('marker'))
# Icon style
icon_style_button = Button(main_frame, text="Icon Style", width=12,
                           command=pick_icon)
icon_style_entry = Entry(main_frame, textvariable=icon_style, width=18)
# Icon color
icon_color_label = Label(main_frame, text="Icon Color:", style='enabled.TLabel')
icon_color_entry = Entry(main_frame, textvariable=icon_color_code, width=13)
icon_color_pick = Button(main_frame, width=1,
                         image=color_picker_icon, compound=RIGHT,
                         command=lambda: pick_color('icon'))
# Save
save_layer_button = Button(main_frame, text="Save Layer", width=13,
                           command=check_fields)
# Default
default_box = Checkbutton(main_frame, text='Use Defaults', onvalue=1, offvalue=0,
                          variable=default_box_var)

# Progress labels, and progress bar
geo_location_status = Label(main_frame, textvariable=geo_loc_stat)
locs_to_process_label = Label(main_frame, textvariable=total_locations_var)
locs_processed_label = Label(main_frame, textvariable=locations_processed_var)
progress_bar = Progressbar(main_frame, orient=HORIZONTAL, mode='determinate', length=280)

# Place Main Frame Widgets
# Cache
use_cached_box.place(x=120, y=13)
show_cached_button.place(x=10, y=10)
# File
file_button.place(x=10, y=50)
file_entry.place(x=120, y=50)
# Layer
layer_label.place(x=15, y=99)
layer_entry.place(x=120, y=90)
# Label Menu
label_label.place(x=15, y=140)
label_menu.place(x=120, y=131)
# Marker Color
marker_color_label.place(x=15, y=179)
marker_color_entry.place(x=120, y=171)
marker_color_pick.place(x=210, y=172)
# Icon Style
icon_style_button.place(x=10, y=220)
icon_style_entry.place(x=120, y=219)
# Icon Color
icon_color_label.place(x=15, y=270)
icon_color_entry.place(x=120, y=261)
icon_color_pick.place(x=210, y=262)
# Save
save_layer_button.place(x=10, y=310)
# Default
default_box.place(x=155, y=312)
# Progress bar and labels
geo_location_status.place(x=5, y=360)
locs_processed_label.place(x=5, y=380)
locs_to_process_label.place(x=5, y=400)
progress_bar.place(x=0, y=420)

# Create Right Frame
right_frame = Frame(base, width=300, height=950)
right_frame.place(x=505, y=13)
# Create Right Frame assets
map_style_var = StringVar()
# Create Right Frame Top
right_frame_top = Frame(right_frame, width=300, height=300)
right_frame_top.place(x=0, y=0)
# Create Right Frame Top Widgets
# Tree View
tree_view = Treeview(right_frame_top)
tree_view.heading(column="#0", text='Layers Created')
tree_view.place(x=0, y=0)
# Scrollbar
scrollbar_y = Scrollbar(right_frame_top, orient=VERTICAL, command=tree_view.yview)
scrollbar_y.place(x=209, y=1, height=260)
tree_view.configure(yscrollcommand=scrollbar_y.set)
# Create Right Frame Bottom
right_frame_bot = Frame(right_frame, width=300, height=400)
right_frame_bot.place(x=0, y=286)
# Create Right Frame Bottom Widgets
# Edit
edit_layer_button = Button(right_frame_bot, text='Edit Layer', width=12,
                           command=edit_layer, state='disabled')
# Delete
delete_layer_button = Button(right_frame_bot, text='Delete Layer', width=12,
                             command=delete_layer, state='disabled')
# Map Style
map_style_button = Button(right_frame_bot, text="Map Style", width=12,
                          command=map_style, state='disabled')
map_style_entry = Entry(right_frame_bot, textvariable=map_style_var, width=14,
                        state='disabled')
# Create Map
create_map_button = Button(right_frame_bot, text="Create Map", width=17,
                           command=create_map)
create_map_button.configure(state='disabled')
stop_button = Button(right_frame_bot, text='Stop', width=10, command=lambda: processing('enabled'),
                     state='disabled')
# Place Right Frame Bottom Widgets
edit_layer_button.place(x=5, y=0)
delete_layer_button.place(x=115, y=0)
map_style_button.place(x=5, y=38)
map_style_entry.place(x=115, y=38)
create_map_button.place(x=40, y=74)
stop_button.place(x=67, y=112)
base.mainloop()
